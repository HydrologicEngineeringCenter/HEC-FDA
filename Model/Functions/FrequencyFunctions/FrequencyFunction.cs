using System;
using System.Collections.Generic;
using FdaModel.Utilities.Messager;
using FdaModel.Utilities.Attributes;
using FdaModel.Functions.OrdinatesFunctions;

namespace FdaModel.Functions.FrequencyFunctions
{
    [Author("John Kucharski", "06/10/2016", "08/22/2016")]
    public abstract class FrequencyFunction : BaseFunction
    {
        #region Notes
        /* 1. Need to add a ViewModel verification that the frequency function is monotonically increasing, otherwise the CreateOrdinatesFunctionFromInterval method will not work as intended. 
         * 2. Documentation for GetCDF function is confusing, and could affect functionality of CreateOrdinatesFunctionFromInterval, need to check to make sure its used correctly. 
         * 3. Replace GetCDF with GetXfromY */
        #endregion

        #region Fields
        protected Statistics.ContinuousDistribution _Function;
        #endregion


        #region Properties
        public virtual Statistics.ContinuousDistribution Function
        {
            get
            {
                return _Function;
            }
            set
            {
                _Function = value;
            }
        }
        #endregion


        #region Constructor
        [Tested(true)]
        /// <summary>
        /// Creates a new frequency function object. 
        /// </summary>
        /// <param name="functionPassedByChildren"> Function generated by the inherited class. </param>
        protected FrequencyFunction(Statistics.ContinuousDistribution functionPassedByChildren, FunctionTypes functionType)
        {
            Function = functionPassedByChildren;
            FunctionType = functionType;
        }
        #endregion

        #region Functions

        //public override OrdinatesFunction GetOrdinatesFunction( )
        //{
        //    int NumberOfOrdinates = 100;

        //    float[ ] Xs = new float[NumberOfOrdinates];
        //    float[ ] Ys = new float[NumberOfOrdinates];
        //    double minY = Function.getDistributedVariable(.0001);
        //    double dY = ( Function.getDistributedVariable(.9999) - minY) / NumberOfOrdinates;
        //    for (int i = 0; i < NumberOfOrdinates; i++)
        //    {
        //        Ys[i] = (float) ( minY + dY * i );
        //        Xs[i] = (float)Function.GetCDF(Ys[i]);
        //    }
        //   return new OrdinatesFunction(Xs, Ys, FunctionType);
        //}

        [Tested(true,true, @"Functions\Frequency Functions\FrequencyFunction\GetOrdinatesFunctionTests.xlsx", "5/26/17","Cody McCoy")]
        public override OrdinatesFunction GetOrdinatesFunction()
        {
            List<double> Xs = new List<double>();
            List<double> Ys = new List<double>();

            Xs.Add(0.0001f);
            Ys.Add(Function.getDistributedVariable(Xs[0]));

            double maxX = 1 - Xs[0];
            double dX = 0.01f;
            double maxY = (float)Function.getDistributedVariable(maxX);
            double dY = (maxY - Ys[0]) * 0.01f;
            double nextX = dX;
            double nextY = dY;
            double incdY = (float)Function.getDistributedVariable(nextX);

            bool halfRangeLessThanDY = false;
            double halfRangeValue = 0;

            int i = 0;

            while (Xs[i] < maxX && Ys[i] + dY < maxY)
            {
                if ((incdY - Ys[Ys.Count - 1]) > dY)
                {
                    //here we have the situation where the flow range between two points is greater then 1% of the total flow range
                    double range = incdY - Ys[Ys.Count - 1];
                    while (halfRangeLessThanDY == false)
                    {
                        halfRangeValue = range / 2;
                        if(halfRangeValue < dY)
                        {
                            
                            Xs.Add((float)Function.GetCDF(Ys[i] + halfRangeValue));
                            Ys.Add(Ys[i] + halfRangeValue);
                            halfRangeLessThanDY = true;
                        }
                        else
                        {
                            range = halfRangeValue;
                        }

                    }
                    halfRangeLessThanDY = false;
                    
                }
                else
                {
                    Xs.Add(nextX);
                    Ys.Add(incdY);
                    nextX += dX;
                    incdY = (float)Function.getDistributedVariable(nextX);
                }

                i++;
            }
            return new OrdinatesFunction(Xs.ToArray(), Ys.ToArray(), FunctionType);
        }

        


        [Tested(true,true, @"Functions\Frequency Functions\FrequencyFunction\Frequency Function Compose Testing.docx","06/06/2017","Cody McCoy")]
        public override OrdinatesFunction Compose(OrdinatesFunction YsFunction, ref List<ErrorMessage> errors)
        {
            int dT = YsFunction.FunctionType - FunctionType;
            switch (dT)
            {
                case 1:
                    break;
                case -1:
                    errors.Add(new ErrorMessage("The input functions cannot be composed. The " + FunctionType + " function must provide the domain of the new composed function. Howerver it is suceeded in the compute sequence by the " + YsFunction.FunctionType + " function.", ErrorMessageEnum.Fatal));
                    return null;
                default:
                    errors.Add(new ErrorMessage("The two input functions do not share a common set of ordinates, a new function cannot be composed. To perform composition the domain (x-ordiantes) of the input function providing the new function's range (y-ordinates) must match range (y-ordiantes) of the input function providing the new function's domain (x-ordinates).", ErrorMessageEnum.Fatal));
                    return null;
            }

            List<double> newXs = new List<double>();
            List<double> newYs = new List<double>();
            double dx = 0.01f, dy = (YsFunction.Function.get_Y(YsFunction.Function.Count - 1) - YsFunction.Function.get_Y(0)) * 0.01f;
            double maxPrecision = .9999;


            int startIndex = FindFirstOverlappingPoint(YsFunction.Function);
            if(startIndex == -1)
            {
                return null;
            }
            else if(startIndex >0)
            {
                GetAllPointsBeforeStartPoint(ref newXs, ref newYs, YsFunction, dx,dy, startIndex, maxPrecision);
            }


            //////////////////////  everything to here seems pretty good
            // now i need to get all the overlapping points from startIndex to the end
            // put that into a new function
            // as you go through the for loop. do if(i+1 == double.isNaN() that way you know which will be the last
            // set of points.

            GetAllOverlappingPoints(ref newXs, ref newYs, startIndex, maxPrecision, dx, dy, YsFunction);
            if(newXs.Count == 0)
            { return null; }
            //check to see if all the probabilities are zero. If that is the case
            //then the frequency function is entirely above the range of the other function
            bool allProbabilitiesZero = true;

            if (newXs[0] < (1-maxPrecision))  //this is .00001
            {
                for (int k = 1;k< newXs.Count;k++)
                {
                    if (newXs[k] >= (1-maxPrecision)) //this is .00001
                    {
                        errors.Add(new ErrorMessage("There is only a partially overlapping range. All values from probability "+newXs[k-1] +" and below will be assigned a value of zero.", ErrorMessageEnum.Major));

                        allProbabilitiesZero = false;
                        break;
                    }
                }
                if (allProbabilitiesZero == true)
                {
                    errors.Add(new ErrorMessage("There is no overlapping range between these two functions.", ErrorMessageEnum.Major));
                    return null;
                }
            }
            

            double unusedRange = 1 - (newXs[newXs.Count - 1] - newXs[0]);
            if (unusedRange > 0.5)
            {
                errors.Add(new ErrorMessage("The composed function contains the domain: [" + newXs[0] + ", " + newXs[newXs.Count - 1] + "]. Higher or lower annual exceedancce probablilites will result in a value of: " + newYs[0] + ", " + newYs[newYs.Count - 1] + "], respectively.", ErrorMessageEnum.Major));
            }
            else
            {
                errors.Add(new ErrorMessage("The composed function contains the domain: [" + newXs[0] + ", " + newXs[newXs.Count - 1] + "]. Higher or lower annual exceedancce probablilites will result in a value of: " + newYs[0] + ", " + newYs[newYs.Count - 1] + "], respectively.", ErrorMessageEnum.Minor));
            }

            return new OrdinatesFunction(newXs.ToArray(), newYs.ToArray(), YsFunction.FunctionType + 1);
        }


        private int FindFirstOverlappingPoint(Statistics.CurveIncreasing curve)
        {
            double newX = 0;
            int returnIndex = 0;
            bool allZeros = true;
            for (int i = 0; i < curve.Count; i++)
            {
                newX = Function.GetCDF(curve.get_X(i));
                if(double.IsNaN(newX) || newX < .0001)
                {

                }
                else
                {
                    allZeros = false;
                    returnIndex = i;
                    break;
                }

            }
            if(allZeros == true)
            {
                //there is no overlap. return -1?
                return -1;
            }
            
            return returnIndex;
        }



        private void GetAllOverlappingPoints(ref List<double> newXs, ref List<double> newYs,int startIndex, double maxPrecision, double dx, double dy, OrdinatesFunction YsFunction)
        {
            List<ErrorMessage> errors = new List<ErrorMessage>();
            double newX;

            for (int i = startIndex; i < YsFunction.Function.Count-1; i++)
            {
                newX = Function.GetCDF(YsFunction.Function.get_X(i));
                if (double.IsNaN(newX) || newX > maxPrecision) // then we are basically done
                {
                    if (newXs.Count == 0) //then there is no overlap!
                    {
                        return;
                    }
                    else //we are at the end
                    {
                        // if the last x is less than .999 and .999 is viable, then add a pt at .999
                        double highestPoint = .999;
                        newX = highestPoint;
                        if (newXs[newXs.Count - 1] < highestPoint)
                        {
                            newXs.Add(newX);
                            newYs.Add(YsFunction.GetYfromX(Function.getDistributedVariable(newX), ref errors));
                        }
                        return;
                    }
                    
                }

                newXs.Add(newX);
                newYs.Add(YsFunction.Function.get_Y(i));
                //}

                //each point will either be 1% of the y value or 1% on the x axis
                //dy is 1% of y values
                //dx is 1% on x axis

                double nextPossiblePoint_OnePercentOfY_YValue = newYs[newYs.Count - 1] + dy;
                double nextPossiblePoint_OnePercentOfY_XValue = Function.GetCDF(newYs[newYs.Count - 1] + dy);

                double nextPossiblePoint_OnePercentOfX_YValue = YsFunction.GetYfromX(Function.getDistributedVariable(newXs[newXs.Count - 1] + dx), ref errors);
                double nextPossiblePoint_OnePercentOfX_XValue = newXs[newXs.Count - 1] + dx;

                double nextYsFunctionYValue = YsFunction.Function.get_Y(i+1); // all points have to be below this value

                //this gets all the points between i and i+1
                while ((nextPossiblePoint_OnePercentOfY_YValue < nextYsFunctionYValue && nextPossiblePoint_OnePercentOfY_XValue < 1) ||
                       (nextPossiblePoint_OnePercentOfX_XValue < 1 && nextPossiblePoint_OnePercentOfX_YValue < nextYsFunctionYValue))
                {
                    if (newYs[newYs.Count - 1] + dy < YsFunction.GetYfromX(Function.getDistributedVariable(newXs[newXs.Count - 1] + dx), ref errors))
                    {
                        newX = Function.GetCDF(YsFunction.GetXfromY(newYs[newYs.Count - 1] + dy, ref errors));
                        if (double.IsNaN(newX) == true)
                        {
                            newX = newXs[newXs.Count - 1] + dx;
                            while (newX < 1 && YsFunction.GetYfromX(Function.getDistributedVariable(newX), ref errors) < YsFunction.Function.get_Y(i + 1))
                            {
                                newXs.Add(newX);
                                newYs.Add(YsFunction.GetYfromX(Function.getDistributedVariable(newX), ref errors));

                                newX += dx;
                            }
                            break;
                        }
                        else
                        {
                            newXs.Add(newX);
                            newYs.Add((newYs[newYs.Count - 1] + dy));
                        }
                    }
                    else
                    {
                        newXs.Add((newXs[newXs.Count - 1] + dx));
                        newYs.Add(YsFunction.GetYfromX(Function.getDistributedVariable(newXs[newXs.Count - 1]), ref errors));
                    }

                    if (newXs[newXs.Count - 1] > maxPrecision)
                    {
                        //here we have actually added one more point then our max.
                        newXs.RemoveAt(newXs.Count - 1);
                        newYs.RemoveAt(newYs.Count - 1);
                        return;
                    } 

                    nextPossiblePoint_OnePercentOfY_YValue = newYs[newYs.Count - 1] + dy;
                    nextPossiblePoint_OnePercentOfY_XValue = Function.GetCDF(newYs[newYs.Count - 1] + dy);
                    nextPossiblePoint_OnePercentOfX_YValue = YsFunction.GetYfromX(Function.getDistributedVariable(newXs[newXs.Count - 1] + dx), ref errors);
                    nextPossiblePoint_OnePercentOfX_XValue = newXs[newXs.Count - 1] + dx;

                }


                //// i dont know what this next part is???
                //if (i == YsFunction.Function.Count - 2)
                //{
                //    newX = Function.GetCDF(YsFunction.GetXfromY(YsFunction.Function.get_Y(i + 1), ref errors));
                //    if (double.IsNaN(newX) == false)
                //    {
                //        newXs.Add(newX);
                //        newYs.Add(YsFunction.Function.get_Y(i + 1));
                //    }
                //}
                //if (newXs[newXs.Count - 1] > maxPrecision) { break; }
            }//end of for loop
             //if we get to here it is possible that there is one last point to add right on the last ordinates function point.
            newX = Function.GetCDF(YsFunction.Function.get_X(YsFunction.Function.Count-1));
            if (double.IsNaN(newX) || newX > maxPrecision) // then i think we are at the end
            {
                return;
            }

            newXs.Add(newX);
            newYs.Add(YsFunction.Function.get_Y(YsFunction.Function.Count-1));

        }

        private void GetAllPointsBeforeStartPoint(ref List<double> newXs, ref List<double> newYs, OrdinatesFunction YsFunction, double dx, double dy, int startIndex, double maxPrecision)
        {
            List<ErrorMessage> errors = new List<ErrorMessage>();

            
            double newX;
            double newY;

            double startingYValue = YsFunction.Function.get_X( startIndex - 1);
            double rangeBetweenStartAndCurrentIndex = YsFunction.Function.get_X(startIndex) - startingYValue;
            double increment = rangeBetweenStartAndCurrentIndex / 100;
            //trying to get the first point
            for (int i = 1;i<100;i++)
            {
                newY =  startingYValue + (i * increment);
                newX = Function.GetCDF(newY);
                if (double.IsNaN(newX) || newX < .0001)
                { }//continue for
                else
                {
                    newXs.Add(newX);
                    newYs.Add(YsFunction.GetYfromX(newY,ref errors));
                    break;
                }
            }
            

            //each point will either be 1% of the y value or 1% on the x axis
            //dy is 1% of y values
            //dx is 1% on x axis

            double nextPossiblePoint_OnePercentOfY_YValue = newYs[newYs.Count - 1] + dy;
            double nextPossiblePoint_OnePercentOfY_XValue = Function.GetCDF(newYs[newYs.Count - 1] + dy);

            double nextPossiblePoint_OnePercentOfX_YValue = YsFunction.GetYfromX(Function.getDistributedVariable(newXs[newXs.Count - 1] + dx), ref errors);
            double nextPossiblePoint_OnePercentOfX_XValue = newXs[newXs.Count - 1] + dx;

            double endYValue = YsFunction.Function.get_Y(startIndex); // all points have to be below this value



            while ((nextPossiblePoint_OnePercentOfY_YValue < endYValue && nextPossiblePoint_OnePercentOfY_XValue < 1) ||
                      (nextPossiblePoint_OnePercentOfX_YValue < endYValue && nextPossiblePoint_OnePercentOfX_XValue < 1))
            {
                if (nextPossiblePoint_OnePercentOfY_YValue < nextPossiblePoint_OnePercentOfX_YValue)
                {
                    newX = Function.GetCDF(YsFunction.GetXfromY(nextPossiblePoint_OnePercentOfY_YValue, ref errors));
                    if (double.IsNaN(newX) == true)
                    {
                        newX = newXs[newXs.Count - 1] + dx;
                        while (newX < 1 && YsFunction.GetYfromX(Function.getDistributedVariable(newX), ref errors) < YsFunction.Function.get_Y(startIndex + 1))
                        {
                            newXs.Add(newX);
                            newYs.Add(YsFunction.GetYfromX(Function.getDistributedVariable(newX), ref errors));

                            newX += dx;
                        }
                        break;
                    }
                    else
                    {
                        newXs.Add(newX);
                        newYs.Add(nextPossiblePoint_OnePercentOfY_YValue);
                    }
                }
                else
                {
                    newXs.Add((newXs[newXs.Count - 1] + dx));
                    newYs.Add(YsFunction.GetYfromX(Function.getDistributedVariable(newXs[newXs.Count - 1]), ref errors));
                }

                if (newXs[newXs.Count - 1] > maxPrecision) { break; }


                nextPossiblePoint_OnePercentOfY_YValue = newYs[newYs.Count - 1] + dy;
                nextPossiblePoint_OnePercentOfY_XValue = Function.GetCDF(newYs[newYs.Count - 1] + dy);
                nextPossiblePoint_OnePercentOfX_YValue = YsFunction.GetYfromX(Function.getDistributedVariable(newXs[newXs.Count - 1] + dx), ref errors);
                nextPossiblePoint_OnePercentOfX_XValue = newXs[newXs.Count - 1] + dx;

            }
        }


        #endregion

    }
}

