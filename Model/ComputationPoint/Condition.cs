using System;
using System.Text;
using System.Collections.Generic;
using FdaModel.Utilities.Attributes;
using FdaModel.Utilities.Messager;
using FdaModel.Functions;
using FdaModel.Functions.FrequencyFunctions;
using FdaModel.Functions.OrdinatesFunctions;
using FdaModel.ComputationPoint.Outputs;

namespace FdaModel.ComputationPoint
{
    [Author("John Kucharski", "10/13/2016")]
    public class Condition: IValidate
    {
        #region Notes
        /* Steps in the compute process:
            1. Construct the computablefunctions class. Validate the list, which will...
                a. check to make sure you provided a list with a sufficient number of functions.
                b. check to make sure you only provided one frequency function.
                c. remove functions that preceed the frequency function.
                d. check to make sure that not more than one function of any particular type was provided (e.g. 2 rating functions)
                e. remove "unsusable functions" e.g. non-monotonically increasing funcctions etc.
                f. put remaining functions in their compute sequence.
                g. check to make sure the compute sequence (e.g. order) is valid.
             2. Run the compute function
          * To Do:
             1. Levee Fragility
             2. Valid Compute for Computed Object generated by compute.
             3. Computation Point in Signature for Computed Object.
             4. Random Numbers
        */
        #endregion


        #region Fields

        private int _Year;
        private string _Location;
        private ModelErrors _Messages;
        private List<BaseFunction> _Functions;
        private PerformanceThreshold _Threshold;
        private LateralStructure _LateralStructure;
        private FunctionTypes _PerformanceComputePoint;
        private bool _IsValid = false;
        private bool _PassedAllValidationTests = true;

        #endregion


        #region Properties
        public bool IsValid
        {
            get { return _IsValid; }
            set { _IsValid = value; }
        }
        public ModelErrors Messages
        {
            get
            {
                return _Messages;
            }
            set
            {
                _Messages = value;
            }
        }

        public int Year
        {
            get
            {
                return _Year;
            }
            set
            {
                _Year = value;
            }
        }

        public string Location
        {
            get
            {
                return _Location;
            }
            set
            {
                _Location = value;
            }
        }

        public List<BaseFunction> Functions
        {
            get
            {
                return _Functions;
            }
            set
            {
                _Functions = value;
            }
        }

        public PerformanceThreshold Threshold
        {
            get
            {
                return _Threshold;
            }
            set
            {
                _Threshold = value;
            }
        }

        public LateralStructure LateralStructure
        {
            get
            {
                return _LateralStructure;
            }
            set
            {
                _LateralStructure = value;
            }
        }

        public FunctionTypes PerformanceComputePoint
        {
            get
            {
                return _PerformanceComputePoint;
            }
            private set
            {
                _PerformanceComputePoint = value;
            }
        }

        #endregion


        #region Constructor
        public Condition(int year, string location, List<BaseFunction> listToCompute, PerformanceThreshold threshold, LateralStructure lateralStructure = null)
        {
            Year = year;
            Location = location;
            Functions = listToCompute;
            Threshold = threshold;
            LateralStructure = lateralStructure;
            Messages = new ModelErrors( );
            Validate( );
            
        }
        #endregion


        #region IValidate Members
        [Tested(true, true, @"M:\Kucharski\Public\Fda\2.0\Testing\Condition\Validate Testing.xlsx", "03/23/2017", "Cody McCoy")]
        /// <summary> Clears messages held in the object's memory and attempts to validate the object's functionality. It reports and saves messages and errors encountered in the validation process. </summary>
        public void Validate()
        {

            Messages.ClearMessages();

            OrderList();
            ValidateYear();
            ValidateEntryPoints();
            ValidateListElements();
            ValidateListSequence(); // if i hit a 5 call "validateExtIntFunction" minor error didnt get to top of levee (2)
            ValidateThreshold();
            ValidateFailureFunction();
            Messages.ReportMessages();

            if (_PassedAllValidationTests == true)
            {
                IsValid = true;
            }
        }


        [Tested(true, true, @"M:\Kucharski\Public\Fda\2.0\Testing\Condition\Validate Testing.xlsx", "03/23/2017", "Cody McCoy")]
        /// <summary> Puts the list of computable functions in the order of the compute sequence. </summary>
        private void OrderList( )
        {
            //FunctionTypes iEnum, jEnum;
            for(int i = 0; i < Functions.Count - 1; i++)
            {
                int j = i + 1;
               
                while(j > 0)
                {
                    if (Functions[j - 1].FunctionType > Functions[j].FunctionType)
                    {
                        BaseFunction temp = Functions[j - 1];
                        Functions[j - 1] = Functions[j];
                        Functions[j] = temp;
                    }
                    j--;
                }
            }

            
        }


        [Tested(true, true, @"M:\Kucharski\Public\Fda\2.0\Testing\Condition\Validate Testing.xlsx", "03/23/2017", "Cody McCoy")]
        /// <summary> Validates the year of the condition. Reports and error it if is outside of the acceptable range. </summary>
        private void ValidateYear( )
        {
            if(_Year < 1900 || _Year > DateTime.Today.Year + 100)
            {
                _PassedAllValidationTests = false;
                Messages.AddMessage(new ErrorMessage("The condition year must be between 1900 and " + (DateTime.Today.Year + 100) + ".", ErrorMessageEnum.Fatal));
            }
        }


        [Tested(true, true, @"M:\Kucharski\Public\Fda\2.0\Testing\Condition\Validate Testing.xlsx", "03/23/2017", "Cody McCoy")]
        /// <summary> Called by Validate method. Finds the entry point(s) (e.g. frequency functions) in the list of function's compute sequence. Removes functions preceeding the first entry point, invalidates the object if more than one entry point (e.g. frequency function) is encountered. </summary>
        private void ValidateEntryPoints( )
        {
            List<ErrorMessage> errors = new List<ErrorMessage>( );
            string message = "The list of functions to compute contains the following entry point(s): ";
            ErrorMessageEnum messageEnum = ErrorMessageEnum.Report;

            bool hasEntry = false;
            for(int i = 0; i < Functions.Count; i++)
            {
                if((int) Functions[i].FunctionType % 2 == 0)
                {
                    if(hasEntry == true)
                    {
                        message += Functions[i].FunctionType + ", ";
                        messageEnum = ErrorMessageEnum.Fatal;
                    }
                    else
                    {
                        hasEntry = true;
                        message += Functions[i].FunctionType + ", ";
                        if (Functions[i].GetType().BaseType != typeof(FrequencyFunction))
                        {
                            Messages.AddMessage(new ErrorMessage("Entry point function is not built from a statistical relationship. Values will be linearly interpolated between points.", ErrorMessageEnum.Major));
                        }
                    }
                }
                else
                {
                    if (Functions[i].FunctionType == FunctionTypes.UnUsed)
                    {
                        errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function is unusable, because it is not montonically increasing or not a function. It cannot be used and has been deleted from the list of functions to compute.", ErrorMessageEnum.Major));
                        Functions.RemoveAt(i);
                        i--;
                        break;
                    }
                    if (hasEntry == false)
                    {
                        errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function occurs before an entry point (e.g. frequency function) in the compute sequence. It cannot be used and has been deleted from the list of functions to compute.", ErrorMessageEnum.Major));
                        Functions.RemoveAt(i);
                        i--;
                    }
                    
                }
            }
            if(hasEntry == false)
            {
                _PassedAllValidationTests = false;
                errors.Add(new ErrorMessage("The list of functions to compute does not contain an entry point (e.g. frequency function) for the compute sequence. The list is not computable.", ErrorMessageEnum.Fatal));
            }
            else
            {
                errors.Add(new ErrorMessage(message, messageEnum));
            }

            Messages.AddMessages(errors);
        }


        [Tested(true, true, @"M:\Kucharski\Public\Fda\2.0\Testing\Condition\Validate Testing.xlsx", "03/23/2017", "Cody McCoy")]
        /// <summary> Called by Validate method. Invalidats the object if duplicat functions are encountered or too few functions are included in the list. </summary>
        private void ValidateListElements( )
        {
            List<ErrorMessage> errors = new List<ErrorMessage>( );

            int count = Functions.Count;
            switch(count)
            {
                case 0:
                    _PassedAllValidationTests = false;
                    errors.Add(new ErrorMessage("No functions were found in the ordered list. A compute cannot be performed on an empty list.", ErrorMessageEnum.Fatal));
                    break;

                case 1:
                    break;

                default:
                    for(int i = 0; i < count - 1; i++)
                    {
                        if(Functions[i].FunctionType == Functions[i + 1].FunctionType)
                        {
                            _PassedAllValidationTests = false;
                            errors.Add(new ErrorMessage("More than one " + Functions[i].FunctionType.ToString( ) + "function was found. A compute cannot be performed because it's ambiguous which function should be used.", ErrorMessageEnum.Fatal));
                        }
                        if(Functions[i].FunctionType == FunctionTypes.UnUsed)
                        {
                            errors.Add(new ErrorMessage("An unusable function was removed from the compute sequence.", ErrorMessageEnum.Major));
                        }
                    }
                    break;
            }

            Messages.AddMessages(errors);
        }


        [Tested(true, true, @"M:\Kucharski\Public\Fda\2.0\Testing\Condition\Validate Testing.xlsx", "03/23/2017", "Cody McCoy")]
        /// <summary> Called by the Validate method. Validates (or invalidates) the compute sequence the list of computable functions, threshold and lateral structure imply. </summary>
        private void ValidateListSequence( )
        {
            List<ErrorMessage> errors = new List<ErrorMessage>( );
            StringBuilder sequence = new StringBuilder("The compute sequence is: ");

            if(Functions.Count == 1)
            {
                ValidateSingleItemListSequence(ref errors);
            }
            else
            {
                FunctionTypes Enum, nextEnum;

                for(int i = 0; i < Functions.Count - 1; i++)
                {
                    Enum = Functions[i].FunctionType;
                    nextEnum = Functions[i + 1].FunctionType;

                    switch(Enum)
                    {
                        case FunctionTypes.InflowFrequency:     //0
                            if(nextEnum != FunctionTypes.InflowOutflow)
                            {
                                Functions[i].FunctionType = FunctionTypes.OutflowFrequency;
                                errors.Add(new ErrorMessage("In the absence of an InflowOutflow function each Inflow is assumed to be equal to the Outflow (e.g. the stream  is assumed to be unregulated). Therefore the InflowFrequency function has been reassigned as an " + FunctionTypes.OutflowFrequency + " function.", ErrorMessageEnum.Report));

                                if(nextEnum == FunctionTypes.Rating)
                                {
                                    errors.Add(new ErrorMessage("The first function in the compute sequence is a " + Functions[i].FunctionType + " frequency function. The next function in the compute sequence is a " + Functions[i + 1].FunctionType + "function. If the stream is regulated a inflow-outflow relationship must be added.", ErrorMessageEnum.Report));
                                }
                                else
                                {
                                    _PassedAllValidationTests = false;
                                    errors.Add(new ErrorMessage("The list contains an " + Functions[i].FunctionType + " function, followed by a " + Functions[i + 1].FunctionType + " function in the compute sequence. These functions do not share an common set of ordinates, thus the compute sequence is invalid.", ErrorMessageEnum.Fatal));
                                }
                            }

                            sequence.Append(Functions[i].FunctionType + "-> ");
                            break;


                        case FunctionTypes.InflowOutflow:           //1
                            if(nextEnum != FunctionTypes.Rating)
                            {
                                _PassedAllValidationTests = false;
                                errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function is followed by a " + Functions[i + 1].FunctionType + " function in the compute sequence. These functions do not share an common set of ordinates, thus the compute sequence is invalid.", ErrorMessageEnum.Fatal));
                            }

                            sequence.Append(Functions[i].FunctionType + "-> ");
                            break;


                        case FunctionTypes.OutflowFrequency:        //2
                            if(nextEnum != FunctionTypes.Rating)
                            {
                                _PassedAllValidationTests = false;
                                errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function is followed by a " + Functions[i + 1].FunctionType + " function in the compute sequence. These functions do not share an common set of ordinates, thus the compute sequence is invalid.", ErrorMessageEnum.Fatal));
                            }

                            sequence.Append(Functions[i].FunctionType + "-> ");
                            break;


                        case FunctionTypes.Rating:                  //3
                            if(nextEnum != FunctionTypes.ExteriorInteriorStage)
                            {
                                if(LateralStructure == null)
                                {
                                    if(nextEnum != FunctionTypes.InteriorStageDamage)
                                    {
                                        _PassedAllValidationTests = false;
                                        errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function is followed by a " + Functions[i + 1].FunctionType + " function in the compute sequence. These functions do not share an common set of ordinates, thus the compute sequence is invalid.", ErrorMessageEnum.Fatal));
                                    }
                                    
                                    Functions.Insert(i + 1, new OrdinatesFunction((Functions[i].GetOrdinatesFunction()).Function.YValues, (Functions[i].GetOrdinatesFunction()).Function.YValues, FunctionTypes.ExteriorInteriorStage));
                                }
                                else
                                {
                                    ValidateLateralStructureFunctions(ref errors);
                                    errors.Add(new ErrorMessage("An exterior-interior function was added to the compute sequence. This ensures damages are truncated (to 0) when the exterior peak stage is below the top of levee and levee failure does not occure (if a levee failure function is provided).", ErrorMessageEnum.Report));
                                }
                            }

                            sequence.Append(Functions[i].FunctionType + "-> ");
                            break;

                        case FunctionTypes.ExteriorStageFrequency:   //4
                            if(nextEnum != FunctionTypes.ExteriorInteriorStage)
                            {
                                if(LateralStructure == null)
                                {
                                    if(nextEnum != FunctionTypes.InteriorStageDamage)
                                    {
                                        _PassedAllValidationTests = false;
                                        errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function is followed by a " + Functions[i + 1].FunctionType + " function in the compute sequence. These functions do not share an common set of ordinates, thus the compute sequence is invalid.", ErrorMessageEnum.Fatal));
                                    }
                                    Functions.Insert(i + 1, new OrdinatesFunction((Functions[i].GetOrdinatesFunction( )).Function.YValues, (Functions[i].GetOrdinatesFunction( )).Function.YValues, FunctionTypes.ExteriorInteriorStage));
                                }
                                else
                                {
                                    ValidateLateralStructureFunctions(ref errors);
                                    errors.Add(new ErrorMessage("An exterior-interior function was added to the compute sequence. This ensures damages are truncated (to 0) when the exterior peak stage is below the top of levee and levee failure does not occure (if a levee failure function is provided).", ErrorMessageEnum.Report));
                                }
                            }

                            sequence.Append(Functions[i].FunctionType + "-> ");
                            break;


                        case FunctionTypes.ExteriorInteriorStage:       //5
                            if(nextEnum != FunctionTypes.InteriorStageDamage && nextEnum != FunctionTypes.LeveeFailure)
                            {
                                _PassedAllValidationTests = false;
                                errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function is followed by a " + Functions[i + 1].FunctionType + " function in the compute sequence. These functions do not share a common set of ordinates, thus the compute sequence is invalid.", ErrorMessageEnum.Fatal));
                            }
                            if(LateralStructure != null && Functions[i].GetOrdinatesFunction().Function.get_X(Functions[i].GetOrdinatesFunction().Function.Count-1) >= LateralStructure.Elevation)
                            {
                                errors.Add(new ErrorMessage("The Exterior Interior Stage function does not contain values that go to the top of the lateral structure. The lateral structure elevation is " + LateralStructure.Elevation + " while the largest exterior stage value is " + Functions[i].GetOrdinatesFunction().Function.get_X(Functions[i].GetOrdinatesFunction().Function.Count - 1) + ".", ErrorMessageEnum.Report));

                            }
                            sequence.Append(Functions[i].FunctionType + "-> ");
                            break;


                        case FunctionTypes.InteriorStageFrequency:      //6
                            errors.Add(new ErrorMessage("An " + Functions[i].FunctionType + " function was found in the compute sequence. This is an atypical entry point (e.g frequency function) in the compute sequence. It is usually derived from performning composition on an exerior (e.g. river channel) stage frequency and interior exterior function.", ErrorMessageEnum.Minor));
                            if(nextEnum != FunctionTypes.InteriorStageDamage && nextEnum != FunctionTypes.LeveeFailure)
                            {
                                _PassedAllValidationTests = false;
                                errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function is followed by a " + Functions[i + 1].FunctionType + " function in the compute sequence. These functions do not share a common set of ordinates, thus the compute sequence is invalid.", ErrorMessageEnum.Fatal));
                            }

                            sequence.Append(Functions[i].FunctionType + "-> ");
                            break;


                        case FunctionTypes.InteriorStageDamage:         //7
                            if(nextEnum != FunctionTypes.LeveeFailure)
                            {
                                _PassedAllValidationTests = false;
                                errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function is followed by a " + Functions[i + 1].FunctionType + " function in the compute sequence. These functions do not share a common set of ordinates, thus the compute sequence is invalid.", ErrorMessageEnum.Fatal));
                            }

                            sequence.Append(Functions[i].FunctionType + "-> ");
                            break;


                        case FunctionTypes.DamageFrequency:             //8
                                                                        //errors.Add(new ErrorMessage("An " + Functions[i].FunctionType + " function was found in the compute sequence. This is an atypical entry point (e.g frequency function) in the compute sequence. It is usually derived during the compute sequence. Since the DamageFrequency function is the last function in the compute results will be based on this, single function.", ErrorMessageEnum.Minor));
                            _PassedAllValidationTests = false;
                            errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function is followed by a " + Functions[i + 1].FunctionType + " function. The " + Functions[i].FunctionType + " function should be the last function in the compute sequence. The list of functions must tbe re-validated.", ErrorMessageEnum.Fatal));

                            sequence.Append(Functions[i].FunctionType + "-> ");
                            break;


                        case FunctionTypes.LeveeFailure:                //9
                            _PassedAllValidationTests = false;
                            errors.Add(new ErrorMessage("The " + Functions[i].FunctionType + " function should be last possible function in a compute sequence. However, it is followed by a " + Functions[i].FunctionType + " function. This is an invalid compute sequence, the list of functions must be revalidated.", ErrorMessageEnum.Fatal));
                            sequence.Append(Functions[i].FunctionType + "-> ");
                            break;
                            // deal with exterior interior relationships with levee fragility.
                    }

                    if(i + 2 == Functions.Count)
                    {
                        sequence.Append(Functions[i + 1].FunctionType + "(End of Compute Sequence).");
                        errors.Add(new ErrorMessage(sequence.ToString( ), ErrorMessageEnum.Report));
                    }
                }
            }

            Messages.AddMessages(errors);
        }


        [Tested(true, true, @"M:\Kucharski\Public\Fda\2.0\Testing\Condition\Validate Testing.xlsx", "03/23/2017", "Cody McCoy")]
        /// <summary> Called by the ValidateListSequence method. Validates (or  invalidates) compute sequences consisting of a single function. Appends messages and errors to a list of error messages passed in as a parameter. </summary>
        /// <param name="errors"> List of error messages to which new messages and errors should be appended. </param>
        private void ValidateSingleItemListSequence(ref List<ErrorMessage> errors)
        {
            FunctionTypes iEnum = Functions[0].FunctionType;

            if((int) iEnum % 2 == 0)
            {
                errors.Add(new ErrorMessage("The list contains a single " + Functions[0].FunctionType + " frequency function. If a compute is performed it will be based on a single function.", ErrorMessageEnum.Minor));

                switch(iEnum)
                {
                    case FunctionTypes.InflowFrequency:
                        Functions[0].FunctionType = FunctionTypes.OutflowFrequency;
                        errors.Add(new ErrorMessage("In the absence of an InflowOutflow function each Inflow is assumed to be equal to the Outflow (e.g. the stream  is assumed to be unregulated). Therefore the InflowFrequency function has been reassigned as an " + FunctionTypes.OutflowFrequency + " function.", ErrorMessageEnum.Report));
                        return;
                    default:
                        return;
                }
            }
            else
            {
                _PassedAllValidationTests = false;
                errors.Add(new ErrorMessage("The list contains a single " + Functions[0].FunctionType + " function, which is not a frequency function. Therefore the list does not contain an entry point and is not computable.", ErrorMessageEnum.Fatal));
                return;
            }
        }


        [Tested(true, true, @"M:\Kucharski\Public\Fda\2.0\Testing\Condition\Validate Testing.xlsx", "03/23/2017", "Cody McCoy")]
        /// <summary> Called by ValidateListSequence method. Validates (or invalidates) the lateral structure contained in the object. Appends messages and errors to a list of error messages passed in as a parameter. </summary>
        /// <param name="errors"> List of error messages to which new messages and errors should be appended. </param>
        private void ValidateLateralStructureFunctions(ref List<ErrorMessage> errors)
        {
            bool hasFailureFunc = false;
            if (Functions[Functions.Count - 1].FunctionType == FunctionTypes.LeveeFailure)
            { hasFailureFunc = true; }
            for(int i = Functions.Count - 1; i >= 0; i--)
            {
                
                if(Functions[i].FunctionType == FunctionTypes.Rating || Functions[i].FunctionType == FunctionTypes.ExteriorStageFrequency)
                {
                    Functions.Insert(i + 1, LateralStructure.CreateInteriorExteriorFunction(Functions[i], hasFailureFunc));
                    errors.Add(new ErrorMessage("An exterior-interior function was added to the compute sequence. This ensures damages are truncated (to 0) when the exterior peak stage is below the top of levee.", ErrorMessageEnum.Report));
                    return;
                }
            }
            _PassedAllValidationTests = false;
            errors.Add(new ErrorMessage("The ValidateLateralStructureFunctions method failed to find a rating curve or exterior-stage frequency function.", ErrorMessageEnum.Fatal));
        }


        /// <summary> Called by Validate method. Sets HasFailureFunction property. Validates (or invalidates) the presence of a levee failure function (its properties are validated during its construction). </summary>
        [Tested(true, true, @"M:\Kucharski\Public\Fda\2.0\Testing\Condition\Validate Testing.xlsx", "03/23/2017", "Cody McCoy")]

        private void ValidateFailureFunction( )
        {
            if (Functions.Count == 0 || Functions[Functions.Count - 1].FunctionType != FunctionTypes.LeveeFailure) { return; }

            if (LateralStructure == null)
            {
                Functions.RemoveAt(Functions.Count - 1);
                Messages.AddMessage(new ErrorMessage("A failure function for a lateral structure was provided in the compute sequence without a corresponding lateral structure. The failure function has been removed.", ErrorMessageEnum.Major));
                return;
            }

            else 
            {
                if (Functions[0].FunctionType > FunctionTypes.ExteriorInteriorStage)
                {
                    Functions.RemoveAt(Functions.Count - 1);
                    Messages.AddMessage(new ErrorMessage("A lateral structure (e.g. levee) failure function was provided in a compute sequence that begins with a " + Functions[0].FunctionType + " function. Thus, no function in the compute sequence contains exterior water surface elevations (e.g. stage) ordinates upon which the levee failure function probabilities are based. The levee failure function has been deleted from the functions in the compute sequence.", ErrorMessageEnum.Major));
                    
                }
                double hundredPercentValue=0;
                for(int i =0;i< Functions[Functions.Count - 1].GetOrdinatesFunction().Function.Count;i++)
                {
                    if(Functions[Functions.Count - 1].GetOrdinatesFunction().Function.get_Y(i) == 1)
                    {
                        hundredPercentValue = Functions[Functions.Count - 1].GetOrdinatesFunction().Function.get_X(i);
                    }
                }
                if(LateralStructure.Elevation < hundredPercentValue)
                {
                    _PassedAllValidationTests = false;
                    Messages.AddMessage(new ErrorMessage("By convention the levee must fail at the top of levee elevation. However, the 100% failure point in the failure function is associated with a stage above the levee. The function must be edited before a compute can be performed.", ErrorMessageEnum.Fatal));

                }

            }


        }


        [Tested(true, true, @"M:\Kucharski\Public\Fda\2.0\Testing\Condition\Validate Testing.xlsx", "03/23/2017", "Cody McCoy")]
        /// <summary> Called by Validate method. Sets PerformanceComputePoint property. Validates (or invalidates) the lateral structure contained in the object. </summary>
        private void ValidateThreshold( )
        {
            List<ErrorMessage> errors = new List<ErrorMessage>( );

            switch(Threshold.ThresholdType)
            {
                //case PerformanceThresholdTypes.LeveeHeight:
                //    PerformanceComputePoint = FunctionTypes.ExteriorStageFrequency;
                //    if(LateralStructure == null)
                //    {
                //        errors.Add(new ErrorMessage("The performance threshold is of type Levee Height, but no lateral structure exists. You must add a lateral structure in order to compute.", ErrorMessageEnum.Fatal));
                //    }
                //    break;

                case PerformanceThresholdTypes.OtherExteriorStage:
                    PerformanceComputePoint = FunctionTypes.ExteriorStageFrequency;
                    break;

                case PerformanceThresholdTypes.InteriorStage:
                    PerformanceComputePoint = FunctionTypes.InteriorStageFrequency;
                    break;

                case PerformanceThresholdTypes.Damage:
                    PerformanceComputePoint = FunctionTypes.DamageFrequency;
                    break;

                case PerformanceThresholdTypes.RelativeDamage:
                    PerformanceComputePoint = FunctionTypes.DamageFrequency;
                    break;
            }
            //if there is a 9 and the comp point is a 4, message the user that the levee failure wont be used
            if(PerformanceComputePoint == FunctionTypes.ExteriorStageFrequency && Functions[Functions.Count-1].FunctionType == FunctionTypes.LeveeFailure)
            {
                errors.Add(new ErrorMessage("The functions provided contain a Levee Failure function but the computation point is " + PerformanceComputePoint + ". The Levee Failure function will play no role in the compute.", ErrorMessageEnum.Minor));
            }
            bool canPerformanceCompPointBeReached = false;
            for(int i = 0; i < Functions.Count; i++)
            {
                //check for the right type of function.
                if(Functions[i].FunctionType == PerformanceComputePoint)
                {
                    canPerformanceCompPointBeReached = true;
                    errors.Add(new ErrorMessage("Project performance calculations based on the " + Threshold.ThresholdType + " threshold will be calculated from the " + PerformanceComputePoint + " function.", ErrorMessageEnum.Report));
                    //check for extra functions that will not be used and report out to user
                    
                        if (Functions.Count > i + 1)
                        {
                            for (int j = Functions.Count - 1; j > i; j--)
                            {
                                if (Functions[j].FunctionType == FunctionTypes.LeveeFailure) { continue; }
                                errors.Add(new ErrorMessage("The " + Functions[j].FunctionType + " function is not necessary to generate a compute with a threshold of " + Threshold.ThresholdType + ".", ErrorMessageEnum.Report));
                            }
                        }
                    
                }
                else if(Functions[i].FunctionType == PerformanceComputePoint - 1)
                {
                    canPerformanceCompPointBeReached = true;
                    errors.Add(new ErrorMessage("Project performance calculations based on the " + Threshold.ThresholdType + " threshold will be calculated from the " + PerformanceComputePoint + " function.", ErrorMessageEnum.Report));
                    //check for extra functions that will not be used and report out to user

                    if (Functions.Count > i + 1)
                    {
                        for (int j = Functions.Count - 1; j > i; j--)
                        {
                            if (Functions[j].FunctionType == FunctionTypes.LeveeFailure) { continue; }
                            errors.Add(new ErrorMessage("The " + Functions[j].FunctionType + " function is not necessary to generate a compute with a threshold of " + Threshold.ThresholdType + ".", ErrorMessageEnum.Report));
                        }
                    }
                }
            }

            




                if (canPerformanceCompPointBeReached == false)
            {
                _PassedAllValidationTests = false;
                errors.Add(new ErrorMessage("The functions provided are not sufficient to produce a successful compute with a threshold type of " + Threshold.ThresholdType + ".", ErrorMessageEnum.Fatal));
            }

            Messages.AddMessages(errors);
        }
        #endregion


        #region Functions everything is commented out
        //public Realization ComputeRealization(Random randomNumberGenerator, bool performanceOnlyCompute)
        //{
        //    List<ErrorMessage> errors = new List<ErrorMessage>( );

        //    if(Messages.IsValid == true)
        //    {
        //        BaseFunction sampledFunction;
        //        OrdinatesFunction composedFunction;
        //        List<BaseFunction> outputList = new List<BaseFunction>( );
        //        double Aep = double.NaN, Ead = double.NaN;

        //        for(int i = 0; i < Functions.Count;i++)
        //        {

        //           sampledFunction = Functions[i].SampleFunction(randomNumberGenerator);
        //           outputList.Add(sampledFunction);

        //            if (i == 0)
        //            {
        //                if(outputList[i].FunctionType == PerformanceComputePoint)
        //                {
        //                    Aep = ComputePerformanceStatistics(outputList[i], ref errors);

        //                    if(performanceOnlyCompute == true)
        //                    {
        //                        return new Realization(this, outputList, new ModelErrors(errors), Aep);
        //                    }
        //                }
        //            }
        //            else
        //            {
        //                if(outputList[outputList.Count - 1].FunctionType == FunctionTypes.ExteriorInteriorStage &&
        //                   Functions[Functions.Count - 1].FunctionType == FunctionTypes.LeveeFailure)
        //                {
        //                    outputList.AddRange(LeveeFailurePoint((OrdinatesFunction)outputList[outputList.Count - 1], randomNumberGenerator));
        //                }
                        
        //                composedFunction = (outputList[outputList.Count - 2]).Compose((OrdinatesFunction)outputList[outputList.Count - 1], ref errors);
        //                outputList.Add(composedFunction);

        //                if(composedFunction.FunctionType == PerformanceComputePoint)
        //                {
        //                    Aep = ComputePerformanceStatistics(composedFunction, ref errors);

        //                    if(performanceOnlyCompute == true)
        //                    {
        //                        return new AepRealization(this, outputList, new ModelErrors(errors), Aep);
        //                    }
        //                }

        //                if(composedFunction.FunctionType == FunctionTypes.DamageFrequency)
        //                {
        //                    Ead = composedFunction.TrapizoidalRiemannSum( );

        //                    if(Aep == double.NaN)
        //                    {
        //                        errors.Add(new ErrorMessage("Aep was not calculated or the result of calculation was not found in the domain of the performance function.", ErrorMessageEnum.Fatal));
        //                    }
        //                    return new EadRealization(this, outputList, new ModelErrors(errors), Aep, Ead);
        //                }
        //            }
                    
        //        }

        //        if(Ead == double.NaN)
        //        {
        //            errors.Add(new ErrorMessage("Aep was not calculated or the result of calculation was not found in the domain of the performance function.", ErrorMessageEnum.Fatal));
        //        }
        //        return new EadRealization(this, outputList, new ModelErrors(errors), Aep, Ead);
        //    }
        //    else
        //    {
        //        Validate( );
        //        if(Messages.IsValid == true)
        //        {
        //            return ComputeRealization(randomNumberGenerator, performanceOnlyCompute);
        //        }
        //        else
        //        {
        //            Messages.AddSingleMessage(new ErrorMessage("One serious errors are associated with the condition that must be resolved before a compute can be performed.", ErrorMessageEnum.Fatal));
        //            return null;
        //        }
        //    }
        //}

        //private double ComputePerformanceStatistics(BaseFunction performanceFunction, ref List<ErrorMessage> errors)
        //{
        //    double Aep;

        //    if(HasFailureFunction == true)
        //    {
        //        throw new NotImplementedException( );
        //    }
        //    else
        //    {
        //        if(performanceFunction.GetType( ).BaseType == typeof(FrequencyFunction))
        //        {
        //            Aep = ((FrequencyFunction) performanceFunction).Function.GetCDF(Threshold.ThresholdValue);
        //        }
        //        else //OrdinatesFunction
        //        {
        //            Aep = ((OrdinatesFunction) performanceFunction).GetXfromY(Threshold.ThresholdValue, ref errors);
        //        }
        //    }       

        //    if(Aep == double.NaN)
        //    {
        //        errors.Add(new ErrorMessage("The performance value matching the threshold value of " + Threshold.ThresholdValue + " could not be found on the domain of the " + performanceFunction + " performance function. Therefore no performance statistic could be computed", ErrorMessageEnum.Fatal));
        //    }
        //    return Aep;
        //}


        



       


        ///// <summary> Samples levee fragility curve and indirectly samples a failure stage (through a random number [0,1] and the failure probability) that is used in AEP and EAD calculations. </summary>
        ///// <param name="exteriorInteriorFunction"></param>
        ///// <param name="randomNumberGenerator"></param>
        ///// <returns></returns>
        //private OrdinatesFunction[] LeveeFailurePoint(OrdinatesFunction exteriorInteriorFunction, Random randomNumberGenerator)
        //{
        //    double failurePoint = randomNumberGenerator.NextDouble( ); 
        //    OrdinatesFunction failureFunction = Functions[Functions.Count - 1].SampleFunction(randomNumberGenerator).GetOrdinatesFunction( );
        //    OrdinatesFunction[ ] sampledFailureOutputFunctions = new OrdinatesFunction[2] { failureFunction, null };

        //    int i = 0, j = 0;
        //    //1. advance exterior-interior function to portion of overlap with levee failure function.
        //    while(exteriorInteriorFunction.Xs[i] < failureFunction.Xs[0])
        //    {
        //        //The exterior-interior function stage is lower than the 0 probability failure stage on the exerior-interior function
        //        exteriorInteriorFunction.Ys[i] = 0;
        //        i++;
        //    }

        //    //2. OR advance levee failure function to portion of overlap with exterior-interior function.
        //    while(exteriorInteriorFunction.Xs[0] > failureFunction.Xs[j])
        //    {
        //        //The levee failure function stage is lower than the lowest stage on the exterior-interior function
        //        j++;
        //    }

        //    if(j != 0)
        //    {
        //        j--;
        //    }

        //    //3. overlapping parts of the curve.
        //    while(exteriorInteriorFunction.Xs[i] >= failureFunction.Xs[j])
        //    {
        //        if(j + 1 == failureFunction.Xs.Length)
        //        {
        //            //a. exterior-interior stage is at or above the probability of 1.0 failure stage.
        //            exteriorInteriorFunction.Ys[i] = exteriorInteriorFunction.Xs[i];
        //            i++;
        //        }
        //        else
        //        {
        //            double probability, dx;
        //            if(exteriorInteriorFunction.Xs[i] < failureFunction.Xs[j + 1])
        //            {
        //                //b. exterior-interior ordinate is between 2 levee failure ordinates
        //                dx = (exteriorInteriorFunction.Xs[i] - failureFunction.Xs[j]) / (failureFunction.Xs[j + 1] - failureFunction.Xs[j]);
        //                probability = failureFunction.Ys[j] + dx * (failureFunction.Ys[j + 1] - failureFunction.Ys[j]);
        //                if(failurePoint < probability)
        //                {
        //                    //levee fails
        //                    exteriorInteriorFunction.Ys[i] = exteriorInteriorFunction.Xs[i];
        //                }
        //                else
        //                {
        //                    //levee holds
        //                    exteriorInteriorFunction.Ys[i] = 0;
        //                }
        //                i++;
        //            }
        //            else
        //            {
        //                //c. exterior stage is beyond range of 2 levee failure stage ordinates being tracked.
        //                j++;
        //            }
        //        }
        //        if(i + 1 == exteriorInteriorFunction.Xs.Length)
        //        {
        //            // reached end of interior exterior function.
        //            sampledFailureOutputFunctions[1] = exteriorInteriorFunction;
        //            break;
        //        }
        //    }
        //    return sampledFailureOutputFunctions; 
        //}
        #endregion


        #region Where Some Old Code Has Gone to be Commented Out.
        //[Tested(false)]
        ///// <summary> Checks for an acceptable computational sequence. </summary>
        ///// <param name="orderedFunctions"></param>
        ///// <returns> True if the provided list of functions can be computed in the order they are arranged, false otherwise. </returns>
        //private bool IsComputableSequence(List<BaseFunction> orderedFunctions)
        //{
        //    FunctionTypes iEnum, nextEnum;
        //    //int iEnum, nextEnum;
        //    for(int i = 0; i < orderedFunctions.Count - 1; i++)
        //    {
        //        iEnum = orderedFunctions[i].FunctionType;
        //        nextEnum = orderedFunctions[i + 1].FunctionType;
        //        switch(iEnum)
        //        {
        //            case FunctionTypes.InflowFrequency:
        //                if(nextEnum == FunctionTypes.InflowOutflow)
        //                {
        //                    break;
        //                }
        //                else if(nextEnum == FunctionTypes.Rating)
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains a frequency function of the type: " + orderedFunctions[i].FunctionType.ToString( ) + "function. " +
        //                                                                   "The next function in the compute sequence is a " + orderedFunctions[i + 1].FunctionType.ToString( ) + "function. " +
        //                                                                   "Consider adding an inflow-outflow relationship, if the streamflow at this point is regulated."
        //                                                                    , ErrorMessageEnum.Model & ErrorMessageEnum.Minor));
        //                    break;
        //                }
        //                else
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains a compute sequence including: a " + orderedFunctions[i].FunctionType.ToString( ) + "function, followed by a " +
        //                                                                   orderedFunctions[i + 1].FunctionType.ToString( ) + "function. This compute sequence is impossible, because these two functions do not share a common set of ordinates."
        //                                                                   , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return false;
        //                }
        //            case FunctionTypes.InflowOutflow:
        //                if(nextEnum == FunctionTypes.Rating)
        //                {
        //                    break;
        //                }
        //                else
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains a compute sequence including: a " + orderedFunctions[i].FunctionType.ToString( ) + "function, followed by a " +
        //                                                                   orderedFunctions[i + 1].FunctionType.ToString( ) + "function. This compute sequence is impossible, because these two functions do not share a common set of ordinates."
        //                                                                   , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return false;
        //                }
        //            case FunctionTypes.OutflowFrequency:
        //                if(nextEnum == FunctionTypes.Rating)
        //                {
        //                    break;
        //                }
        //                else
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains a compute sequence including: a " + orderedFunctions[i].FunctionType.ToString( ) + "function, followed by a " +
        //                                                                   orderedFunctions[i + 1].FunctionType.ToString( ) + "function. This compute sequence is impossible, because these two functions do not share a common set of ordinates."
        //                                                                   , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return false;
        //                }
        //            case FunctionTypes.Rating:
        //                if(nextEnum == FunctionTypes.ExteriorInteriorStage)
        //                {
        //                    break;
        //                }
        //                else if(nextEnum == FunctionTypes.InteriorStageDamage)
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains a generic rating curve (e.g. flow exterior-stage function). " +
        //                                                                   "The next function in the compute sequence is a " + orderedFunctions[i + 1].FunctionType.ToString( ) + "function. " +
        //                                                                   "It is assumed that the interior-stage and exterior-stage at this computation point are identical, for every event. " +
        //                                                                   "A exterior-stage interior-stage relationship must be added if this is not the case."
        //                                                                    , ErrorMessageEnum.Model & ErrorMessageEnum.Minor));
        //                    break;
        //                }
        //                else if(nextEnum == FunctionTypes.LeveeFailure)
        //                {
        //                    break;
        //                }
        //                else
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains a compute sequence including: a " + orderedFunctions[i].FunctionType.ToString( ) + "function, followed by a " +
        //                                                                   orderedFunctions[i + 1].FunctionType.ToString( ) + "function. This compute sequence is impossible, because these two functions do not share a common set of ordinates."
        //                                                                   , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return false;
        //                }
        //            case FunctionTypes.ExteriorStageFrequency:
        //                if(nextEnum == FunctionTypes.ExteriorInteriorStage)
        //                {
        //                    break;
        //                }
        //                else if(nextEnum == FunctionTypes.InteriorStageDamage)
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains an exterior-stage frequency function. " +
        //                                                                   "The next function in the compute sequence is a " + orderedFunctions[i + 1].FunctionType.ToString( ) + "function. " +
        //                                                                   "It is assumed that the interior-stage and exterior-stage at this computation point are identical, for every event. " +
        //                                                                   "A exterior-stage interior-stage relationship must be added if this is not the case."
        //                                                                    , ErrorMessageEnum.Model & ErrorMessageEnum.Minor));
        //                    break;
        //                }
        //                else if(nextEnum == FunctionTypes.LeveeFailure)
        //                {
        //                    break;
        //                }
        //                else
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains a compute sequence including: a " + orderedFunctions[i].FunctionType.ToString( ) + "function, followed by a " +
        //                                                                   orderedFunctions[i + 1].FunctionType.ToString( ) + "function. This compute sequence is impossible, because these two functions do not share a common set of ordinates."
        //                                                                   , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return false;
        //                }
        //            case FunctionTypes.ExteriorInteriorStage:
        //                if(nextEnum == FunctionTypes.InteriorStageDamage)
        //                {
        //                    break;
        //                }
        //                else if(nextEnum == FunctionTypes.LeveeFailure)
        //                {
        //                    break;
        //                }
        //                else
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains a compute sequence including: a " + orderedFunctions[i].FunctionType.ToString( ) + "function, followed by a " +
        //                                                                   orderedFunctions[i + 1].FunctionType.ToString( ) + "function. This compute sequence is impossible, because these two functions do not share a common set of ordinates."
        //                                                                   , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return false;
        //                }
        //            case FunctionTypes.InteriorStageFrequency:
        //                if(nextEnum == FunctionTypes.InteriorStageDamage)
        //                {
        //                    break;
        //                }
        //                else if(nextEnum == FunctionTypes.LeveeFailure)
        //                {
        //                    break;
        //                }
        //                else
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains a compute sequence including: a " + orderedFunctions[i].FunctionType.ToString( ) + "function, followed by a " +
        //                                                                   orderedFunctions[i + 1].FunctionType.ToString( ) + "function. This compute sequence is impossible, because these two functions do not share a common set of ordinates."
        //                                                                   , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return false;
        //                }
        //            case FunctionTypes.InteriorStageDamage:
        //                if(nextEnum == FunctionTypes.LeveeFailure)
        //                {
        //                    break;
        //                }
        //                else
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The ordered list of functions contains a compute sequence including: a " + orderedFunctions[i].FunctionType.ToString( ) + "function, followed by a " +
        //                                                                   orderedFunctions[i + 1].FunctionType.ToString( ) + "function. This compute sequence is impossible, because these two functions do not share a common set of ordinates."
        //                                                                   , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return false;
        //                }
        //            default:
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("A " + orderedFunctions[i].FunctionType.ToString( ) + "function, is contained in the ordered list. " +
        //                                                                   "This type of function is either uncomputable (e.g. unused type) or can only be created during the compute." +
        //                                                                   "Remove this function, or case it as a proper but different type and retry."
        //                                                                   , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return false;
        //                }
        //        }
        //    }
        //    return true;
        //}

        //[Tested(false)]
        ///// <summary> Places functions in the enumerated order defined in the function types enum. </summary>
        ///// <param name="unorderedFunctions"></param>
        ///// <returns> The list of provided functions, in the correct enumerated order (which corresponds with the compute order after trimming). </returns>
        //private List<BaseFunction> OrderFunctions(List<BaseFunction> unorderedFunctions)
        //{
        //    int iEnum, jEnum;
        //    for(int i = 0; i < unorderedFunctions.Count; i++)
        //    {
        //        iEnum = (int) unorderedFunctions[i].FunctionType;
        //        for(int j = 1; j < unorderedFunctions.Count - 1; j++)
        //        {
        //            jEnum = (int) unorderedFunctions[j].FunctionType;
        //            if(jEnum < iEnum)
        //            {
        //                unorderedFunctions.Insert(i, unorderedFunctions[j]);
        //                unorderedFunctions.RemoveAt(j + 1);
        //                j++;
        //            }
        //        }
        //    }
        //    return unorderedFunctions;
        //}

        //[Tested(false)]
        ///// <summary> Checks the order, types and sequence of functions. Edits the list where possible to produce a valid list, or returns an error messages and a null result. </summary>
        ///// <param name="functionsToValidate"></param>
        ///// <returns> A list of functions with a computable order, types and sequence or error messages and a null result. </returns>
        ///// <remarks> The list of functions must validated through this routine (or the void method with the same name) before a compute can occur. </remarks>
        //private List<BaseFunction> Validate(List<BaseFunction> functionsToValidate, LateralStructure lateralStructureToCompute, PerformanceThreshold threshold)
        //{
        //    // I. Order Functions
        //    //FunctionTypes iEnum, jEnum;
        //    for(int i = 0; i < functionsToValidate.Count; i++)
        //    {
        //        int index_of_min = i;
        //        //iEnum = functionsToValidate[i].FunctionType;
        //        for(int j = i; j < functionsToValidate.Count; j++)
        //        {
        //            if(functionsToValidate[index_of_min].FunctionType > functionsToValidate[j].FunctionType)
        //            {
        //                index_of_min = j;
        //            }
        //        }
        //        BaseFunction temp = functionsToValidate[i];
        //        functionsToValidate[i] = functionsToValidate[index_of_min];
        //        functionsToValidate[index_of_min] = temp;
        //        //jEnum = functionsToValidate[j].FunctionType;
        //        //if (iEnum > jEnum)
        //        //{

        //        //functionsToValidate.Insert(i, functionsToValidate[j]);
        //        //functionsToValidate.RemoveAt(j + 1);
        //        //j++;
        //        //}
        //        //}
        //    }

        //    // II. Check Length of List and Ensure NO Duplicates Exist
        //    if(functionsToValidate.Count < 1)
        //    {
        //        Logger.Instance.ReportMessage(new ErrorMessage("No functions were found in the ordered list. A compute cannot be performed on an empty list."
        //                                      , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //        return null;
        //    }
        //    else
        //    {
        //        int i = 0, nEntryPoints = 0;
        //        FunctionTypes entryPoint = FunctionTypes.InflowFrequency;
        //        while(i < functionsToValidate.Count)
        //        {
        //            if(i < functionsToValidate.Count - 1)//all functions except the last one in the list
        //            {
        //                // 1. Check Computation Points (make sure they are the same).
        //                if(functionsToValidate[i].IndexPoint != functionsToValidate[i + 1].IndexPoint)
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("Functions from more than one index point where encountered. " +
        //                                                  "In particular the following (Name, Condition, Analysis Year, Stream) index point pairs were where encountered: " +
        //                                                  "(" + functionsToValidate[i].IndexPoint.Name.ToString( ) + ", " + functionsToValidate[i].IndexPoint.Condition.ToString( ) + ", " + functionsToValidate[i].IndexPoint.AnalysisYear.ToString( ) + ", " + functionsToValidate[i].IndexPoint.Stream.ToString( ) + "), " +
        //                                                  "(" + functionsToValidate[i + 1].IndexPoint.Name.ToString( ) + ", " + functionsToValidate[i + 1].IndexPoint.Condition.ToString( ) + ", " + functionsToValidate[i + 1].IndexPoint.AnalysisYear.ToString( ) + ", " + functionsToValidate[i + 1].IndexPoint.Stream.ToString( ) + "), " +
        //                                                  "A compute cannot be performed because it is abigious which should be computed."
        //                                                  , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return null;
        //                }


        //                // 2. Check for More Than One Function of a Single Type.
        //                if(functionsToValidate[i].FunctionType == functionsToValidate[i + 1].FunctionType)
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("More than one " + functionsToValidate[i].FunctionType.ToString( ) + "function was found. " +
        //                                                  "A compute cannot be performed because it's ambiguous which function should be used.", ErrorMessageEnum.Fatal));
        //                    return null;
        //                }
        //            }

        //            // 3. Find Frequency Function(s) (e.g. entry Point)
        //            if((int) functionsToValidate[i].FunctionType % 2 == 0)
        //            {
        //                nEntryPoints++;
        //                //a. Check for (e.g. error on) Multiple Frequency Functions (e.g. too many entry points)
        //                if(nEntryPoints > 1)
        //                {
        //                    Logger.Instance.ReportMessage(new ErrorMessage("More than one frequency function was provided. It is not possible to compute with more than one set of frequencies, " +
        //                                                  "because which set of frequencies should be used is abigious."
        //                                                  , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                    return null;
        //                }
        //                entryPoint = functionsToValidate[i].FunctionType;
        //            }
        //            else//4. Validate Transform Function (or unusable types)
        //            {
        //                //a. Remove Tranform Functions (e.g. odd enums) Before Entry Point
        //                if(functionsToValidate[i].FunctionType < entryPoint)
        //                {
        //                    functionsToValidate.RemoveAt(i);
        //                    Logger.Instance.ReportMessage(new ErrorMessage("The " + functionsToValidate[i].FunctionType.ToString( ) + "preceeds the provided frequency function in the compute sequence. " +
        //                                                  "This function will be deleted from the computable list. " +
        //                                                  "However, The program will continue attempting to create a computable list, from the remaining provided functions."
        //                                                  , ErrorMessageEnum.Model & ErrorMessageEnum.Major));
        //                    continue;                     //the ith observation changes as a result of the removal, re-evaluate same i.
        //                }

        //                //b. Remove Unusable Function (which are odd)
        //                if(functionsToValidate[i].FunctionType == FunctionTypes.UnUsed)
        //                {
        //                    functionsToValidate.RemoveAt(i);
        //                    Logger.Instance.ReportMessage(new ErrorMessage("One or more of the provided functions cannot be used in the compute, because they contain errors or are not monotonically increasing. " +
        //                                                  "This function will be deleted from the computable list. " +
        //                                                  "However, The program will continue attempting to create a computable list, from the remaining functions in the provided list."
        //                                                  , ErrorMessageEnum.Model & ErrorMessageEnum.Major));
        //                    continue;                     //the ith observation changes as a result of the removal, re-evaluate same i.
        //                }
        //            }

        //            //III. If a lateral structure without fragility exists then the exterior-interior relationship either needs to be created or modified).
        //            if(lateralStructureToCompute != null)
        //            {
        //                //1. Check the Failure Probability of the Lateral Structure at the Top Elevation.
        //                if(lateralStructureToCompute.FailureFunction == null)
        //                {
        //                    //2. Check for an ExteriorInteriorStage Function
        //                    if(functionsToValidate[i].FunctionType >= FunctionTypes.ExteriorInteriorStage)
        //                    {
        //                        //a. Edit the Existing ExteriorInteriorStage function
        //                        if(functionsToValidate[i].FunctionType == FunctionTypes.ExteriorInteriorStage)
        //                        {

        //                            // i. check or edit the exterior-interior functions interior elevations below the top of the lateral structure.
        //                            if(functionsToValidate[i].GetType( ) == typeof(UncertainOrdinatesFunction))
        //                            {
        //                                UncertainOrdinatesFunction stageFunction = (UncertainOrdinatesFunction) functionsToValidate[i];
        //                                //*if exterior stage mean plus 4 standard deviations is below top of leevee remove Y distribution
        //                                throw new Exception("Figure out how to deal with uncertain ordinates function exception.");
        //                            }
        //                            else if(functionsToValidate[i].GetType( ) == typeof(IncreasingOrdinatesFunction))
        //                            {
        //                                IncreasingOrdinatesFunction stageFunction = (IncreasingOrdinatesFunction) functionsToValidate[i];
        //                                for(int j = 0; j < stageFunction.Xs.Length; j++)
        //                                {
        //                                    if(stageFunction.Xs[i] < lateralStructureToCompute.Elevation)
        //                                    {
        //                                        if(stageFunction.Ys[i] > 0)
        //                                        {
        //                                            stageFunction.Ys[i] = 0;
        //                                            Logger.Instance.ReportMessage(new ErrorMessage("The exterior water elevation of: " + stageFunction.Xs[i] + " is below the top of the lateral structure elevation, listed at: " + lateralStructureToCompute.Elevation + ". " +
        //                                                                                           "No failure function is associated with the lateral structure, thus it is assumed not to fail below an elevation of: " + lateralStructureToCompute.Elevation + ". " +
        //                                                                                           "However, this exterior water surface elevation is associated with an interior water surface elevation of: " + stageFunction.Ys[i] + ", this is contradictory to the no failure assumption." +
        //                                                                                           "The interior water surface elevation has been set to 0 to ensure flooding is not simulated below the top of the lateral structure. If flooding should be simulated below the top of levee, a failure function must be added."
        //                                                                                           , ErrorMessageEnum.Model & ErrorMessageEnum.Major));
        //                                        }
        //                                    }
        //                                }
        //                            }
        //                            else
        //                            {
        //                                Logger.Instance.ReportMessage(new ErrorMessage("The Exterior-Interior function is not a usable type."
        //                                                                               , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                                return null;
        //                            }
        //                        }
        //                        //b. Add an ExteriorInteriorStage Function
        //                        else
        //                        {
        //                            // i. Found the Insertion Point (the last function (i - 1) is it in the compute sequence, (i) is after it). 
        //                            if(functionsToValidate[i - 1].FunctionType < FunctionTypes.ExteriorInteriorStage)
        //                            {

        //                                //A. Find the Type of the ExteriorStageFrequency Function or Report an Error if its not a ExteriorStage-Frequency Function
        //                                IncreasingOrdinatesFunction stageFunction;
        //                                if(functionsToValidate[i - 1].FunctionType == FunctionTypes.ExteriorStageFrequency)
        //                                {
        //                                    if(functionsToValidate[i - 1].GetType( ) == typeof(FrequencyFunction))
        //                                    {
        //                                        stageFunction = ((FrequencyFunction) functionsToValidate[i - 1]).GetOrdinates( );
        //                                    }
        //                                    else if(functionsToValidate[i - 1].GetType( ) == typeof(IncreasingOrdinatesFunction))
        //                                    {
        //                                        stageFunction = (IncreasingOrdinatesFunction) functionsToValidate[i - 1];
        //                                    }
        //                                    else
        //                                    {
        //                                        Logger.Instance.ReportMessage(new ErrorMessage("The Exterior Stage Frequency function is not a usable type."
        //                                                                      , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                                        return null;
        //                                    }
        //                                }
        //                                else if(functionsToValidate[i - 1].FunctionType == FunctionTypes.Rating)
        //                                {
        //                                    Random randomNumberGenerator = new Random(0);
        //                                    BaseFunction sampledFunction = functionsToValidate[i - 1].SampleFunction(randomNumberGenerator);
        //                                    if(sampledFunction.GetType( ) == typeof(IncreasingOrdinatesFunction))
        //                                    {
        //                                        stageFunction = (IncreasingOrdinatesFunction) sampledFunction;
        //                                    }
        //                                    else
        //                                    {
        //                                        Logger.Instance.ReportMessage(new ErrorMessage("The Rating function is not a usable type."
        //                                                                      , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                                        return null;
        //                                    }
        //                                }
        //                                else
        //                                {
        //                                    Logger.Instance.ReportMessage(new ErrorMessage("The compute with a lateral structure requires and exterior stage relationship but none was found."
        //                                                                  , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                                    return null;
        //                                }
        //                                //B. Create the Exterior-Interior Function
        //                                float[ ] Xs = new float[stageFunction.Ys.Length], Ys = new float[stageFunction.Ys.Length];
        //                                for(int j = 0; j < stageFunction.Ys.Length; j++)
        //                                {
        //                                    Xs[i] = stageFunction.Ys[i];
        //                                    if(Xs[i] <= lateralStructureToCompute.Elevation)
        //                                    {
        //                                        Ys[i] = 0;
        //                                    }
        //                                    else
        //                                    {
        //                                        Ys[i] = Xs[i];
        //                                    }
        //                                }
        //                                BaseFunction exteriorInteriorFunction = OrdinatesFunction.OrdinatesFunctionFactory(functionsToValidate[i - 1].IndexPoint, Xs, Ys, FunctionTypes.ExteriorInteriorStage);

        //                                // 3. Add the Exterior-Interior Function to the List of Base Functions. 
        //                                if(exteriorInteriorFunction.GetType( ) == typeof(IncreasingOrdinatesFunction))
        //                                {
        //                                    functionsToValidate.Insert(i, exteriorInteriorFunction);
        //                                }
        //                                else
        //                                {
        //                                    Logger.Instance.ReportMessage(new ErrorMessage("The program generated a exterior-interior stage function from the lateral structure elevation that is not monotonically increasing."
        //                                                                  , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                                    return null;
        //                                }

        //                            }

        //                        }
        //                    }
        //                }
        //                else //4. Evaluate if the Failure Function has a Probability of Failure = 1 above the Top of Levee Height.
        //                {
        //                    IncreasingOrdinatesFunction failureFunction;
        //                    if(lateralStructureToCompute.FailureFunction.GetType( ) == typeof(IncreasingOrdinatesFunction))
        //                    {
        //                        failureFunction = (IncreasingOrdinatesFunction) lateralStructureToCompute.FailureFunction;
        //                        for(int j = 0; j < failureFunction.Xs.Length; j++)
        //                        {
        //                            if(failureFunction.Xs[i] >= lateralStructureToCompute.Elevation)
        //                            {
        //                                if(failureFunction.Ys[i] != 1)
        //                                {
        //                                    Logger.Instance.ReportMessage(new ErrorMessage("By convention there must be probability of failure at or above the top of the lateral structure height must be equal to 1. " +
        //                                                                                   "In the failure function a elevation of " + failureFunction.Xs[i] + "which is " +
        //                                                                                   (failureFunction.Xs[i] - lateralStructureToCompute.Elevation) + " above the top of the lateral structure is associated wtih a " +
        //                                                                                   failureFunction.Ys[i] + "chance of failure. This issue must be resolved before a compute can occur."
        //                                                                                   , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                                    return null;
        //                                }
        //                            }
        //                        }
        //                    }
        //                    else
        //                    {
        //                        Logger.Instance.ReportMessage(new ErrorMessage("The lateral structure failure function is not monontically increasing and therefore cannot be used in the compute."
        //                                                                       , ErrorMessageEnum.Model & ErrorMessageEnum.Fatal));
        //                        return null;
        //                    }
        //                }
        //            }
        //            i++;
        //        }

        //        //5. Check if Usable Functions Remain.
        //        if(functionsToValidate.Count < 1)
        //        {
        //            Logger.Instance.ReportMessage(new ErrorMessage("None of the provided functions could be used in the compute. Each function contained errors or was not monontonically increasing. " +
        //                                                           "As a result the compute was terminated.", ErrorMessageEnum.Fatal));
        //            return null;
        //        }

        //        //6. Error if No Frequency Function was Found (e.g. even number function)
        //        if(nEntryPoints == 0)
        //        {
        //            Logger.Instance.ReportMessage(new ErrorMessage("No usable frequency function was found in the provided list of functions." +
        //                                                           "As a result the compute was terminated.", ErrorMessageEnum.Fatal));

        //            return null;
        //        }
        //    }
        //    //IV. Check for Computable Sequence from Ordered List (and trimmed List)
        //    if(IsComputableSequence(functionsToValidate) == true)
        //    {
        //        return functionsToValidate;
        //    }
        //    else
        //    {
        //        Logger.Instance.ReportMessage(new ErrorMessage("The list of functions are not computable in their current sequence.", ErrorMessageEnum.Fatal));
        //        return null;
        //    }
        //}
        #endregion
    }

}
